# 9184 신나는 함수 실행
------------
### 문제

>재귀 호출만 생각하면 신이 난다! 아닌가요?
>
>다음과 같은 재귀함수 w(a, b, c)가 있다.
>
>```
>if a <= 0 or b <= 0 or c <= 0, then w(a, b, c) returns:
>    1
>
>if a > 20 or b > 20 or c > 20, then w(a, b, c) returns:
>    w(20, 20, 20)
>
>if a < b and b < c, then w(a, b, c) returns:
>    w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)
>
>otherwise it returns:
>    w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)
>```
>위의 함수를 구현하는 것은 매우 쉽다. 하지만, 그대로 구현하면 값을 구하는데 매우 오랜 시간이 걸린다. (예를 들면, a=15, b=15, c=15)
>
>a, b, c가 주어졌을 때, w(a, b, c)를 출력하는 프로그램을 작성하시오.

### 아이디어
----------
위 문제는 재귀함수와 메모이제이션 DP를 이용하여 풀 수 있었다.

문제 자체에서 재귀 함수의 조건을 준다. 재귀함수는 따라 치기만 해도 되고 우리가 구현해야 할 것은 이것의 결과들을 메모이제이션으로 바꿔 시간을 줄여주는 것이다.  

조건에서 a,b,c중 하나라도 1보다 작으면 1, 하나라도 20보다 크면 (20,20,20)으로 바꿔주기 때문에 [0]~[20]까지만 만들면 된다.

DP[21][21][21](a,b,c)를 선언한 뒤, 재귀 함수를 구현할 때 동시에 메모이제이션 기능을 구현시켜준다.  

```c++
int f(int a, int b, int c)
{
    if (a <= 0 || b <= 0 || c <= 0)
        return 1;
    if (a > 20 || b > 20 || c > 20)
        return f(20, 20, 20);
    if (DP[a][b][c])
        return DP[a][b][c];
    if (a < b && b < c)
    {
        DP[a][b][c] = f(a, b, c - 1) + f(a, b - 1, c - 1) - f(a, b - 1, c);
        return DP[a][b][c];
    }
    DP[a][b][c] = f(a - 1, b, c) + f(a - 1, b - 1, c) + f(a - 1, b, c - 1) - f(a - 1, b - 1, c - 1);
    return DP[a][b][c];
}
```

### 오답노트
----------
