# 11444 피보나치 수 6
------------
### 문제

>피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.
>
>이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.
>
>n=17일때 까지 피보나치 수를 써보면 다음과 같다.
>
>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597
>
>n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.

### 아이디어
----------
위 문제는 행렬 멱법을 이용하여 풀 수 있었다.

보통 피보나치 문제들은 DP 메모이제이션을 이용하여 O(N)으로 풀 수 있다.

하지만 해당 문제는 N의 크기제한도 엄청나게 크고 시간제한도 짧으므로 O(N)으로도 시간 초과가 뜬다.  
그렇기에 해당 문제를 풀기 위해 방법을 찾던 도중 새로운 방법을 알게되었다.

__행렬 멱법__
>
> <img width="30%" src="https://blog.kakaocdn.net/dn/cqh6aE/btrg7YMje6s/isPMqXVTWBO8tv5TmMqIK0/img.png">
>
> 위 사진과 같이 {(1,1),(1,0)}의 배열을 n만큼 제곱하면 해당 행렬의 0,0에 n번째 피보나치 수열이 나온다.

위 방법을 이용하여 재귀를 통해 코드를 짰다.

또한 코드 구현부분에서 중요한 부분은 고속 거듭제곱 알고리즘이다.  
거듭제곱 코드에서 해당 알고리즘을 사용하여 지수가 홀수라면 한번 더 곱해주는 로직을 구현하게 된다면 log2N만큼 시간복잡도가 줄기 때문에 해당 알고리즘 또한 이용해주면 여유롭게 시간을 통과한다. 

### 오답노트
----------
이문제 거의 포기했었는데 클래스 4 중간문제 다풀고 이거 하나남아서 어쩔수없이 방법 이해하고 클리어함.

원래 계속 DP나 재귀로 풀어서 시간복잡도 나왔는데 행렬로 푸니까 원리는 완전 이해는 못했지만 신기하긴 했음.