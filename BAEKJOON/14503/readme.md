# 14503 로봇 청소기
------------
### 문제

>로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.
>
>로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다. 지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터 떨어진 칸의 개수이다.
>
>로봇 청소기는 다음과 같이 작동한다.
>
>1. 현재 위치를 청소한다.
>2. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향부터 차례대로 인접한 칸을 탐색한다.
>   a. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
>   b. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
>   c. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
>   d. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.   
>로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.

### 아이디어
----------
위 문제는 시뮬레이션 문제이다.

위에서 주어진 조건대로 잘 구현만 하면 금방 풀 수 있다.

단 현재 방향과 회전할 방향의 기준을 통합해서 잘 잡아야 안 헷갈린다.  
나는 바라보는 방향에서 왼쪽을 기준으로 잡아서 왼하오상 순으로 만들었다.  
또한 문제에서 주어지는 방향에서는 0123이 반시계로 주어지기 때문에 1과 3을 바꿔줘서 시계방향으로 해줬다.

시뮬레이션 부분 함수에 주석처리 해뒀으니 궁금하면 해석하며 보시길

```c++
void simul()
{
    while (arr[V.r][V.c] != 1) // 시작지점이 벽일 때를 대비
    {
        arr[V.r][V.c] = 2;          // 해당칸 청소
        bool isgo = false;          // 전진 여부
        for (int i = 0; i < 4; i++) // 왼쪽으로 돌며 사방 확인
        {
            if (arr[V.r + ym[V.d]][V.c + xm[V.d]] == 0)
            {                // 왼쪽칸이 빈칸이라면
                isgo = true; // 해당칸으로 전진
                V.r += ym[V.d];
                V.c += xm[V.d];
                V.d = (V.d + 1) % 4; // 왼쪽으로 회전
                break;
            }
            V.d = (V.d + 1) % 4; // 왼쪽으로 회전
        }
        if (!isgo)
        { // 사방으로 갈 수 없으며
            if (arr[V.r + ym[(V.d + 1) % 4]][V.c + xm[(V.d + 1) % 4]] == 1)
            {           // 뒤가 벽이라면
                return; //종료
            }
            else
            {                             // 뒤가 이미 청소한 길이라면
                V.r += ym[(V.d + 1) % 4]; // 방향 유지한체 후진
                V.c += xm[(V.d + 1) % 4];
            }
        }
    }
}
```

### 오답노트
----------
왼쪽으로 기준을 잡고 후진할 때 +2를 하니까 3번 돌아서 +1을 해주는 방식으로 고쳤다.