# 17135 캐슬 디펜스
------------
### 문제

>캐슬 디펜스는 성을 향해 몰려오는 적을 잡는 턴 방식의 게임이다. 게임이 진행되는 곳은 크기가 N×M인 격자판으로 나타낼 수 있다. 격자판은 1×1 크기의 칸으로 나누어져 있고, 각 칸에 포함된 적의 수는 최대 하나이다. 격자판의 N번행의 바로 아래(N+1번 행)의 모든 칸에는 성이 있다.
>
>성을 적에게서 지키기 위해 궁수 3명을 배치하려고 한다. 궁수는 성이 있는 칸에 배치할 수 있고, 하나의 칸에는 최대 1명의 궁수만 있을 수 있다. 각각의 턴마다 궁수는 적 하나를 공격할 수 있고, 모든 궁수는 동시에 공격한다. 궁수가 공격하는 적은 거리가 D이하인 적 중에서 가장 가까운 적이고, 그러한 적이 여럿일 경우에는 가장 왼쪽에 있는 적을 공격한다. 같은 적이 여러 궁수에게 공격당할 수 있다. 공격받은 적은 게임에서 제외된다. 궁수의 공격이 끝나면, 적이 이동한다. 적은 아래로 한 칸 이동하며, 성이 있는 칸으로 이동한 경우에는 게임에서 제외된다. 모든 적이 격자판에서 제외되면 게임이 끝난다. 
>
>게임 설명에서 보다시피 궁수를 배치한 이후의 게임 진행은 정해져있다. 따라서, 이 게임은 궁수의 위치가 중요하다. 격자판의 상태가 주어졌을 때, 궁수의 공격으로 제거할 수 있는 적의 최대 수를 계산해보자.
>
>격자판의 두 위치 (r1, c1), (r2, c2)의 거리는 |r1-r2| + |c1-c2|이다.

### 아이디어 
----------
위 문제는 시뮬레이션 문제이다.  
문제를 풀기 위해서 필요한 알고리즘은 다음과 같다.

- 브루트포스 : 3명의 궁수 위치를 모든 경우에 다 배치해보기 위함.
- bfs : 각 궁수로부터 가장 가깝고 왼쪽에 위치한 적을 찾기 위함.
- 재귀 : brute force를 사용하기 위함.

코드의 구성은 
1. brute force를 재귀 함수로 구현하여 3명의 궁수를 배치할 수 있는 모든 경우에 배치한다.
2. 배치한 상황에서 N번 만큼 다음 함수를 반복해준다.
3. 궁수가 3명이므로 3번 bfs 반복한다.
4. bfs에서 queue를 이용해 가장 가깝고 왼쪽에 위치한 적의 위치를 저장한다.
5. 돌아와 저장된 적을 순서대로 제거하며 kill++을 해주고 중복이라면 kill을 올리지 않는다.
6. 해당 재귀 함수의 row가 0이라면 마지막 턴이므로 max값을 비교해 저장하고 돌아간다.
7. 위 brute force를 재귀로 반복해주고 최댓값을 출력한다.

### 오답노트
----------
