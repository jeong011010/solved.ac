# 2206번 벽 부수고 이동하기
------------
### 문제

>N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.  
>
>만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.
>
>한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.
>
>맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.

### 아이디어
----------
위 문제는 BFS 알고리즘을 통해 풀 수 있었다.
BFS 알고리즘은 queue를 사용하여 간단하게 만들 수 있었지만, 벽을 부수고 이동하는 경우가 생겨 다양한 예외처리를 설계하느라 어려웠던 문제이다.

우선 기본 베이스는 다음과 같이 설정하였다.
>- 1002*1002 크기의 배열을 선언한 뒤, 시작점을 (1,1)로 잡아주고 맵 테두리 (0,0부터 0,n, 0,0부터 m,0 ...)를 2로 초기화 해준다.  
>- map에 0과 1로 길과 벽을 입력받아준다.  
>- visited 배열을 1002*1002*2인 3차원 배열로 잡아줬다. 해당 이유는 아래 오답노트에서 설명하겠다.
>- tile 구조체를 선언하여 좌표 (n,m), count, 벽 부순 여부 bool함수를 넣은 뒤 해당 자료형으로 queue를 선언해줬다.

이후 bfs 설계는 아래와 같다.
- queue(이하 q)에 1,1,1,0(n,m,count,wall(bool))를 push해준 뒤, q.empty while문을 돌려준다.
- 상하좌우 배열을 받아온 뒤, 카운트를 올리고 벽 여부에 따라 visited 3차원 배열을 활용하여 q.push 및 visited = true를 해준다.

### 오답노트
----------
- 처음 위 문제를 풀 때, 순조롭게 잘 풀었는데 위에서 다 풀고난 뒤 재출하니 21%에서 오류가 났다. 이유를 찾다보니 [블로그](https://hqjang.tistory.com/69)에서 찾을 수 있었다.
- 처음 풀었을 때는 vistied 배열 대신 방문한 곳 arr 값을 2로 바꿔주는 방법을 사용했다.
```
6 3
000
110
000
011
111
000
```
- 위와 같은 경우, (2,1)에 있는 벽을 부수고 먼저 내려간 case에서 (3,1),(3,2),(3,3)을 먼저 2로 만들게 된다.
- 그렇게되면 (2,3)에서 밑으로 내려올 수 없게되어 최소 길이 12가 막히며 -1이 출력되는 오류가 있었다.

- 그렇기에 visited 배열을 두개로 만들어 벽을 부순 뒤의 visited 배열과 그렇지 않은 배열 두개로 나누어 진행하였다.