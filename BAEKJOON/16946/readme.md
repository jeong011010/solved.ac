# 16946 벽 부수고 이동하기 4
------------
### 문제

>N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 한 칸에서 다른 칸으로 이동하려면, 두 칸이 인접해야 한다. 두 칸이 변을 공유할 때, 인접하다고 한다.
>
>각각의 벽에 대해서 다음을 구해보려고 한다.
>
>- 벽을 부수고 이동할 수 있는 곳으로 변경한다.  
>- 그 위치에서 이동할 수 있는 칸의 개수를 세어본다.  
>한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.

### 아이디어
----------
위 문제는 dfs와 구현으로 풀 수 있었다.

문제 자체는 간단하다.  
1(벽)으로부터 사방으로 뚫려있는 0의 개수를 각 벽마다 구하면 된다.  

그래서 처음에 벽 좌표를 vector에 저장해둔 뒤, dfs로 0의 개수를 해당 벽 배열 값에 더해줬다.  
하지만 모든 벽을 이미 갔던 공간(0) 포함해서 전부 둘러보기엔 시간이 턱없이 모자랐다.  

해결책을 찾아보던 중, 반대로 생각하여 공간(0)을 dfs로 하여 해당 공간을 갔을 때 몇개의 공간을 방문할 수 있는지 계산해둔 뒤, 이후 저장해둔 벽의 사방이 공간이라면 더하면 되는 것이었다.

그렇기에 이중 for문으로 공간을 탐색하며 공간 발견시 다른 공간과 겹쳐지지 않도록 해당 공간 모두를 cnt로 만들어줬다.  
즉 0인 부분만 갈 수 있도록 하며, 이후 사방 탐색중 공간의 cnt가 겹친다면 해당 공간은 겹친것이므로 더하지 않는 방식으로 했다.  
그러기 위해 map을 사용하여 (key(cnt), count(공간개수))로 저장해줬다.

### 오답노트
----------
