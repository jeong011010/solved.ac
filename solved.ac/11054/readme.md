# 11053 가장 긴 증가하는 부분 수열
------------
### 문제

>수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.
>
>예를 들어, {10, 20, __30__, 25, 20}과 {10, 20, 30, __40__}, {__50__, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.
>
>수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

### 아이디어
----------
위 문제는 DP로 풀 수 있다.

위 문제를 풀기 위해 점화식부터 세워봤다.
우선 DP로 풀 때, 이전에 현재 값보다 작은 수가 몇개 있는지 세어 저장하면 된다.

>ex) 
>1 5 2 1 4 3 4 5 2 1 의 경우
>1 2 2 1 3 3 4 5 2 1 - 왼쪽에서부터
>1 5 2 1 4 3 3 3 2 1 - 오른쪽에서부터
>이렇게 한 뒤, 두 배열을 합쳐 가장 큰 것이 가장 긴 바이토닉 수열이다.
>여기서 배열 두개를 합치는 과정에서 Sk가 중복되므로 1을 빼준다.
>그럼 가장 큰 수열의 길이는 5+3-1인 7이다.

위 과정이 이루어지기 위해서는 2중 포문을 사용한다.
DP[i]=1로 초기화해준 뒤, 2중 포문에서 현재 값보다 작은 값을 발견하였으며, 해당 index의 DP가 현재 DP보다 크거나 같으면 현재 DP에 1을 더해준다.

```c++
for(int i=0;i<N;i++){
        DP1[i]=1;
        for(int j=0;j<=i;j++)
            if(arr[j]<arr[i]&&DP1[i]<=DP1[j])
                DP1[i]++;
    }
```

반대로도 해준 뒤 배열 값을 합치고 1을 빼준다.

### 오답노트
----------
반대 DP 배열에서 N부터 0까지 확인해야 하는데 >0으로 해서 1까지 확인해버렸다. (98% 오류)
해당 반례는
2
2 1
답 : 2
풀이 : 1 이다.