# 2096번 내려가기
------------
### 문제

>N줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다. 내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다.  
>
>먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다. 그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이 있다. 바로 아래의 수로 넘어가거나, 아니면 바로 아래의 수와 붙어 있는 수로만 이동할 수 있다는 것이다. 이 제약 조건을 그림으로 나타내어 보면 다음과 같다.
>
><img width="40%" src="https://www.acmicpc.net/JudgeOnline/upload/201007/down.png"/>
>
>별표는 현재 위치이고, 그 아랫 줄의 파란 동그라미는 원룡이가 다음 줄로 내려갈 수 있는 위치이며, 빨간 가위표는 원룡이가 내려갈 수 없는 위치가 된다. 숫자표가 주어져 있을 때, 얻을 수 있는 최대 점수, 최소 점수를 구하는 프로그램을 작성하시오. 점수는 원룡이가 위치한 곳의 수의 합이다.

### 아이디어
----------
위 문제는 DP를 사용하여 푸는 문제이다.
위 그림처럼 상황이 있을 때, 1,2,3번째 칸에서 이동할 수 있는 경우의 수가 각각 다르다.
그렇기에 칸마다 다르게 max, min 함수를 구현해준다.

또한 최소와 최대를 구해야하기 때문에 dp 배열 두개를 만들어준다.

특징으로는 메모리 제한이 4MB이므로 N의 최대값인 100000만큼 배열을 만들 수 없다.
그렇기에 슬라이딩 윈도우 알고리즘을 사용하여 메모리를 최소한으로 사용하며 DP를 구현한다.

해당 문제를 풀며 배운 새로운 알고리즘 sliding window algorithm은 다음과 같다.

- __Sliding Window__
> 서브 배열의 중복되는 범위를 재사용하는 것이다.
> 슬라이딩 윈도우의 시작 index와 끝 index를 이용하여 그 사이 중복되지 않는 새로운 수를 더하고 사라진 수를 뺀다.
> 위 문제에 적용 시킬 경우
>> 크기 3의 배열의 크기 2인 2차원 배열을 선언한다. (arr[3][2])
>> arr[i][1]에 현재 값 + MAX(arr[i][0],arr[i][1],arr[i][2])를 대입한다.
>> 이후 arr[i][0]에 arr[i][1]값을 옮겨준다.
> 해당 과정을 반복하면 크기 6*(int)배열인 적은 메모리 공간으로 효율적으로 계산할 수 있다.

### 오답노트
----------
- 우선 처음 풀 때 설계 안하고 무작정 dp로 풀어서 위에걸 기준으로 하고 아래중 큰곳에 더하는 방식으로 했다.
그랬다가 나중에 보니까
```
1 5 1
1 1 5
5 1 1
```
과 같은 경우에서 최대값이 15가 나오는 불상사가 일어났다.
- 다른 사람들의 풀이를 보고 우선 DP 구현부터 잘못되었으며, 만약 고치더라도 크기가 [100001][3]인 배열 두개를 사용하게 되어 메모리를 초과하게 되었을 것이다.
- 위 상황을 대처하기 위해 sliding window 알고리즘을 공부하여 사용하게 되었다.

- 필수 알고리즘을 사용해야만 풀 수 있는 문제가 있기도 하다. 언젠간 도움이 될거라고 생각하고 머릿속에 간단하게라도 저장하도록 하자.
- 그리고 DP 설계 연습을 진짜 해야겠다.