# 1932번 정수 삼각형
------------
### 문제

>
```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```
>위 그림은 크기가 5인 정수 삼각형의 한 모습이다.  
>>맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.  
>>삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.

### 아이디어
----------
위 문제는 Dynamic Programming 알고리즘을 이용하여 푸는 문제이다.
DP를 이용하기 위해서는 우선 점화식을 구현해야 했다.
점화식 구현 과정은 아래와 같았다.
1. 층마다 위의 수 두개 중 큰 것과 더하여 DP에 넣는다.
2. 여기서 층의 가장 앞과 뒤 숫자는 비교할 것이 없으므로 if 처리를 해준다.
- 해당 부분은 x와 tmp를 이용하여 시작과 끝을 판단해줬다.
- 또한 각 층의 부모 시작 index를 n으로 잡아주었다.
3. priority queue에 결과를 전부 넣은 뒤 pq.top을 출력해준다.

DP 함수 소스코드는 다음과 같이 구현하였다.
```
void dp(){
    priority_queue<int> pq;
    int x=1,tmp=2,n=0;
    DP.push_back(v[0]);
    pq.push(DP[0]);
    for(int i=1;i<v.size();i++){
        if(x==1){DP.push_back(DP[n]+v[i]);n++;}
        else if(x==tmp){DP.push_back(DP[n-1]+v[i]);x=0;tmp++;}
        else{DP.push_back(MAX(DP[n-1],DP[n])+v[i]);n++;}
        pq.push(DP[i]);
        x++;
    }
    cout<<pq.top();
}
```

### 오답노트
----------
- DP를 사용하지 않고 무작정 하였다가 시간 초과 오류가 발생했다 ^^;;
- 점화식을 만드는게 제일 오래 걸렸다.. 그리면서 규칙을 찾아 점화식을 구현하는게 은근 재밌으면서 간단하다.
- 층이 1층일 경우 pq에 아무것도 없는 경우가 생겨 오류가 발생했다. 위 경우를 방지하기 위해 시작 부분에 pq에 v[0]을 추가해줬다.