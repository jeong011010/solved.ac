# 12865 평범한 배낭
------------
### 문제

>이 문제는 아주 평범한 배낭에 관한 문제이다.
>
>한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.
>
>준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

### 아이디어
----------
위 문제는 __배낭 문제__를 기반으로 한 DP를 이용하여 푸는 문제이다.

나도 이 문제 풀면서 처음 알게 된 알고리즘인데, 자세한건 다음에 블로그에 정리해서 올리겠다.

- 배낭 문제
> 배낭안에 넣을 수 있는 최대 무게가 K.
> 배낭에 넣을 수 있는 N개의 물건이 각기다른 가치 V, 무게 W를 가지고 있다.
> 배낭이 최대한 가치가 높은 물건들을 담을 수 있는 조합을 찾는 문제이다.
>
> 해당 문제를 Brute Force로 풀 경우 모든 조합을 만들기 위해선 2^n개의 경우의 수를 시도해봐야 한다. 그렇기에 매우 비효율적인 풀이방법이 될것이다.
>
> 그렇기 때문에 DP 알고리즘을 사용하는 것이다.
> 물건개수 n과 총 무게 w로 2차원 배열을 만든다.
> 배낭 문제의 DP 점화식은 아래와 같다.
>
> DP[n][w] = max(DP[n-1][w],DP[n][w-j]) (j = n번째 넣은 물건의 무게)
> 

위 문제를 기반으로 DP 알고리즘을 사용해 해당 문제를 풀었다.
최대 무게인 100000+1과 최대 물건 개수인 100+1로 2차원 배열을 만든다.

이후 2중 for문을 이용하여 현재 무게가 지금 물건의 무게보다 가볍다면(배낭에 넣을 수 있다면), 이전 물건의 해당 무게가 최대 무게를 초과하지 않으며, 이전 물건의 무게보다 무겁다면 해당 무게로 초기화해준다.

말로는 복잡하니 DP 코드를 붙혀두겠다.
```C++
for(int i=1;i<=N;i++){
        int W=pq.top().first;
        int V=pq.top().second;
        pq.pop();

        for(int j=1;j<=K;j++){
            if(W<=j){
                if(V + DP[i-1][j-W] > DP[i-1][j])
                    DP[i][j] = V + DP[i-1][j-W];
                else DP[i][j] = DP[i-1][j];
            }
            else
                DP[i][j] = DP[i-1][j];
        }
    }
```


### 오답노트
----------
풀어오던 DP 문제였지만 서브 문제를 어떻게 풀어야할 지 감이 잡히지 않아 검색을 해봤다.
배낭 문제라는 걸 알게 되었고, 풀이방법 또한 알 수 있었다.