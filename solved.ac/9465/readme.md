# 9251 LCS
------------
### 문제

>상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.
>
>상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.
>
><img width="90%" src="https://www.acmicpc.net/upload/images/sticker.png"/>
>
>모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오. 즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.
>
>위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.

### 아이디어
----------
위 문제는 Dynamic Programming 알고리즘을 이용하여 풀었다. (뭔가 DP 특집인 느낌..? 안그래도 필요하긴 했음 ㅋㅋ)
DP 점화식을 바로 구하기 시작하였다.
1. 우선 배열 시작점을 1로 잡은 뒤, [1][0]과 [1][1]에 값을 미리 대입해둔다.
2. for문으로 2부터 시작하게 한 뒤 점화식을 사용한다.
3. DP[i][j] = arr[i][j];
4. if(DP[i-2][j==0?1:0]>DP[i-1][j==0?1:0]) 
    - true -> DP[i][j]+=DP[i-2][j==0?1:0]
    - false -> DP[i][j]+=DP[i-1][j==0?1:0]
저렇게 하는 이유는 해당 스티커를 골랐을 때, 이전 스티커를 고르는 경우의 수는 
1. 한칸 전 대각선 스티커 (그 스티커는 그 전 대각선 스티커를 골랐기때문에,)
2. 두칸 전 대각선 스티커 (두칸 전 직선 스티커는 앞에 스티커에 누적됨.) 
총 두가지 경우이다.

다음은 위 내용을 구현한 DP 함수이다.
```C++
int DP[100001][2];
    DP[1][0]=arr[1][0];
    DP[1][1]=arr[1][1];
    for(int i=2;i<=n;i++){
        for(int j=0;j<2;j++){
            DP[i][j]=arr[i][j];
            if(DP[i-1][j==0?1:0]>DP[i-2][j==0?1:0])
                DP[i][j]+=DP[i-1][j==0?1:0];
            else
                DP[i][j]+=DP[i-2][j==0?1:0];
        }
    }
```

### 오답노트
----------
DP[i-1][!j]와 DP[i-2][!j]를 비교하면 되었는데 쓸데없이 arr[i-1][!j]+arr[i-2][j]와 arr[i-2][!j]를 비교하는 불필요한 연산을 하여 [해당 경우](https://www.acmicpc.net/board/view/58194)에서 에러가 발생했다.